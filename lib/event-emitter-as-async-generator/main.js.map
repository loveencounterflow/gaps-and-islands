{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../../src/event-emitter-as-async-generator/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n\n\n'use strict'\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'EVENTS-AS-GENERATOR'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nPATH                      = require 'path'\n# FS                        = require 'fs'\ntypes                     = new ( require 'intertype' ).Intertype()\nMIXA                      = require 'mixa'\nSL                        = require 'intertext-splitlines'\n{ freeze, }               = Object\n\n\n### thx to https://stackoverflow.com/a/59347615/7568091\n\nSeems to be working so far.\n\ni.e. you create a dummy promise like in Khanh's solution so that you can wait for the first result, but then\nbecause many results might come in all at once, you push them into an array and reset the promise to wait\nfor the result (or batch of results). It doesn't matter if this promise gets overwritten dozens of times\nbefore its ever awaited.\n\nThen we can yield all the results at once with yield* and flush the array for the next batch.\n\n###\n\n\n#-----------------------------------------------------------------------------------------------------------\ngenerate_lines_of_text = ( delay, stream_nr ) -> new Promise ( done ) =>\n  process.stdout.write \"generating lines with delay: #{rpr delay}\\n\"\n  sleep = ( dts ) -> new Promise ( done ) => setTimeout done, dts * 1000\n  text  = \"\"\"just a generator demo for stream_nr: #{stream_nr} ###\"\"\"\n  if module is require.main then do =>\n    process.stdout.write 'helo' + '\\n'\n    words = text.split /\\s+/\n    for word in words\n      process.stdout.write '\\n'\n      process.stdout.write JSON.stringify { $key: '^line', stream_nr, word, }\n      if delay isnt 0\n        await sleep delay\n    process.stdout.write '\\n'\n    process.stderr.write \"and hello over the other channel!\\n\"\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\nclass Receiver # extends Object\n  constructor: ->\n    @collector            = []\n    @[ Symbol.iterator ]  = -> yield from @collector; @collector = []\n    @_resolve             = ->\n    @done                 = false\n    @initializer          = null\n    @is_first             = true\n    @send                 = _send.bind @\n    @advance              = _advance.bind @\n    @ratchet              = new Promise ( resolve ) => @_resolve = resolve\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  add_data_channel: ( eventemitter, eventname, $key ) ->\n    switch type = types.type_of $key\n      when 'text'\n        types.validate.nonempty_text $key\n        handler = ( $value ) =>\n          @send freeze { $key, $value, }\n          @advance()\n      when 'function'\n        handler = ( $value ) =>\n          @send $key $value\n          @advance()\n      when 'generatorfunction'\n        handler = ( $value ) =>\n          @send d for d from $key $value\n          @advance()\n      else\n        throw new Error \"^receiver/add_data_channel@445^ expected a text, a function, or a generatorfunction, got a #{type}\"\n    eventemitter.on eventname, handler\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  ### TAINT make `$key` behave as in `add_data_channel()` ###\n  add_initializer: ( $key ) ->\n    ### Send a datom before any other data. ###\n    types.validate.nonempty_text $key\n    @initializer = freeze { $key, }\n\n  #---------------------------------------------------------------------------------------------------------\n  ### TAINT make `$key` behave as in `add_data_channel()` ###\n  add_terminator: ( eventemitter, eventname, $key = null ) ->\n    ### Terminates async iterator after sending an optional datom to mark termination in stream. ###\n    eventemitter.on eventname, =>\n      @send freeze { $key, } if $key?\n      @advance false\n\n  #---------------------------------------------------------------------------------------------------------\n  @from_child_process: ( cp, settings ) ->\n    # defaults  = {}\n    # settings  = { defaults..., }\n    ### TAINT validate settings ###\n    rcv       = new Receiver()\n    rcv.add_initializer   '<cp'\n    rcv.add_data_channel cp.stdout, 'data', '^stdout'\n    rcv.add_data_channel cp.stderr, 'data', '^stderr'\n    rcv.add_terminator cp, 'close', '>cp'\n    while not rcv.done\n      await rcv.ratchet; yield from rcv\n    return null\n\n#-----------------------------------------------------------------------------------------------------------\n_send = ( d ) ->\n  if @is_first\n    @is_first = false\n    @collector.push @initializer if @initializer?\n  @collector.push d\n\n#-----------------------------------------------------------------------------------------------------------\n_advance  = ( go_on = true ) ->\n  @done     = not go_on\n  @_resolve()\n  @ratchet  = new Promise ( resolve ) => @_resolve = resolve\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\ncustom_receiver_from_child_process = ( cp ) ->\n  rcv           = new Receiver()\n  #.........................................................................................................\n  ### Add an initializer (data to be always sent once before any other): ###\n  rcv.add_initializer   '<cp'\n  #.........................................................................................................\n  ### Use a `$key` for the datom to be sent: ###\n  rcv.add_data_channel cp.stdout, 'data', '^stdout'\n  #.........................................................................................................\n  ### Can also use an iterator to send anything in response to `$value`: ###\n  rcv.add_data_channel cp.stderr, 'data', ( $value ) ->\n    yield \"next event is from stderr\"\n    yield freeze { $key: '^stderr', $value, }\n  #.........................................................................................................\n  ### Add a terminator, otherwise stream will not close properly; here, we make it also send a datom after\n  all regular data has been sent: ###\n  rcv.add_terminator cp, 'close', '>cp'\n  #.........................................................................................................\n  while not rcv.done\n    await rcv.ratchet; yield from rcv\n  help \"^8743^ receiver: no more data\"\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\ncreate_receiving_pipeline = ( delay ) -> new Promise ( resolve_outer, reject_outer ) =>\n  #---------------------------------------------------------------------------------------------------------\n  SP = require 'steampipes'\n  { $\n    $watch\n    $drain }  = SP.export()\n  #---------------------------------------------------------------------------------------------------------\n  $split_channels = ->\n    splitliners = {}\n    last        = Symbol 'last'\n    return $ { last, }, ( d, send ) =>\n      { $key, $value, } = d\n      unless ( ctx = splitliners[ $key ] )?\n        ctx = splitliners[ $key ] = SL.new_context()\n      if d is last\n        send ( freeze { $key, $value, } ) for $value from SL.flush ctx\n        return null\n      return send d if ( not d? ) or ( not types.isa.buffer d.$value )\n      send ( freeze { $key, $value, } ) for $value from SL.walk_lines ctx, $value\n      return null\n  #---------------------------------------------------------------------------------------------------------\n  source      = SP.new_push_source()\n  pipeline    = []\n  pipeline.push source\n  pipeline.push $split_channels()\n  pipeline.push $watch ( d ) ->\n    ### TAINT not a good way to find out whether $value should be parsed ###\n    try info JSON.parse d.$value catch error then urge d\n  pipeline.push $drain ->\n    help \"^3776^ pipeline: finished\"\n    return resolve_outer()\n  SP.pull pipeline...\n  #.........................................................................................................\n  { spawn }   = require 'child_process'\n  cp          = spawn 'node', [ __filename, 'generate', '--nr', '1', '--delay', \"#{delay}\", ]\n  source.send x for await x from Receiver.from_child_process cp\n  cp          = spawn 'node', [ __filename, 'generate', '--nr', '2', '--delay', \"#{delay}\", ]\n  source.send x for await x from custom_receiver_from_child_process cp\n  source.end()\n  return null\n\n#-----------------------------------------------------------------------------------------------------------\ncli = -> new Promise ( done ) =>\n  #.........................................................................................................\n  runner = ( d ) =>\n    delay = d.verdict.parameters.delay\n    nr    = d.verdict.parameters.nr\n    switch d.verdict.cmd\n      when 'generate' then await generate_lines_of_text delay, nr\n      when 'receive'  then await create_receiving_pipeline delay\n      else throw new Error \"^cli@33336^ unknown command #{rpr d.verdict.cmd}\"\n    done()\n  #.........................................................................................................\n  jobdefs =\n    commands:\n      #.....................................................................................................\n      'generate':\n        description:  \"generate series of words in different speeds\"\n        flags:\n          'delay':  { alias: 'd', fallback: 0, type: Number, description: \"seconds to pause between each chunk of data\", }\n          'nr':     { fallback: 1, description: \"stream identifier to be used\", }\n        runner: runner\n      #.....................................................................................................\n      'receive':\n        description:  \"spawn subprocess and process signals it emits\"\n        flags:\n          'delay':  { alias: 'd', fallback: 0, type: Number, description: \"seconds to pause between each chunk of data\", }\n        runner: runner\n  #.........................................................................................................\n  MIXA.run jobdefs, process.argv\n  return null\n\n############################################################################################################\nif module is require.main then do =>\n  # await demo_receiver()\n  await cli()\n\n\n"
  ]
}