{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/read-undecoded-lines-from-stdin.coffee"
  ],
  "names": [],
  "mappings": "AAEA;AAAA,MAAA,KAAA,EAAA,IAAA,EAAA,GAAA,EAAA,mBAAA,EAAA;;EAAA,KAAA,GAAY,OAAO,CAAC;;EACpB,GAAA,GAAY,CAAE,OAAA,CAAQ,MAAR,CAAF,CAAkB,CAAC;;EAC/B,CAAA,CAAE,IAAF,CAAA,GAAY,OAAA,CAAQ,QAAR,CAAZ,EAFA;;;;;;EASA,YAAA,GAAe,MAAA,QAAA,CAAA,CAAA;AACf,QAAA,QAAA,EAAA;IAAE,QAAA,GAAY,OAAA,CAAQ,UAAR;IACZ,EAAA,GAAK,QAAQ,CAAC,eAAT,CAAyB;MAC5B,KAAA,EAAc,OAAO,CAAC,KADM;MAE5B,MAAA,EAAc,OAAO,CAAC,MAFM;MAG5B,WAAA,EAAc,CAHc;MAI5B,SAAA,EAAc,KAJc;MAK5B,QAAA,EAAc;IALc,CAAzB;IAML,EAAE,CAAC,EAAH,CAAM,MAAN,EAAc,CAAE,IAAF,CAAA,GAAA,EAAA;;MAEZ,IAAA,GAAO,IAAI,CAAC,OAAL,CAAa,oBAAb,EAAmC,KAAnC;aACP,OAAO,CAAC,MAAM,CAAC,KAAf,CAAqB,IAAA,GAAO,IAA5B;IAHY,CAAd;WAIA,CAAA,MAAM,IAAA,CAAK,EAAL,EAAS,OAAT,CAAN;EAZa,EATf;;;EAwBA,mBAAA,GAAsB,QAAA,CAAA,CAAA;WAAG,IAAI,OAAJ,CAAY,KAAA,CAAE,OAAF,EAAW,MAAX,CAAA,GAAA;AACrC,UAAA,EAAA,EAAA,cAAA,EAAA,GAAA,EAAA,GAAA,EAAA,QAAA,EAAA,KAAA,EAAA;MAAE,EAAA,GAAkB,OAAA,CAAQ,sBAAR;MAClB,CAAA,CAAE,KAAF,EACE,MADF,CAAA,GACkB,OADlB;MAEA,QAAA,GAAkB;QAAE,MAAA,EAAQ,KAAV;QAAiB,aAAA,EAAe;MAAhC;MAClB,cAAA,GAAkB,QAAA,CAAE,MAAF,CAAA;eAAc,KAAA,GAAQ,CAAE,MAAM,CAAC,QAAP,CAAgB,KAAhB,CAAF;MAAtB;MAClB,GAAA,GAAkB,EAAE,CAAC,WAAH,CAAe,QAAf;MAClB,GAAA,GAAkB,EANpB;;MAQE,KAAK,CAAC,EAAN,CAAS,MAAT,EAAiB,QAAA,CAAE,CAAF,CAAA;AACnB,YAAA,IAAA,EAAA,GAAA,EAAA;AAAI;AAAA;QAAA,KAAA,WAAA;UACE,GAAA;uBACA,MAAM,CAAC,KAAP,CAAe,CAAA,QAAA,CAAA,CAAW,GAAX,CAAA,CAAA,CAAF,GAAwB,CAAE,cAAA,CAAe,IAAf,CAAF,CAAxB,GAAkD,IAA/D;QAFF,CAAA;;MADe,CAAjB,EARF;;MAaE,MAAM,OAAO,CAAC,KAAK,CAAC,IAAd,CAAmB,KAAnB,EAA0B,QAAA,CAAA,CAAA;AAClC,YAAA,IAAA,EAAA,GAAA,EAAA;AAAI;AAAA;QAAA,KAAA,WAAA;UACE,GAAA;UACA,MAAM,CAAC,KAAP,CAAe,CAAA,QAAA,CAAA,CAAW,GAAX,CAAA,CAAA,CAAF,GAAwB,CAAE,cAAA,CAAe,IAAf,CAAF,CAAxB,GAAkD,IAA/D;uBACA,OAAA,CAAA;QAHF,CAAA;;MAD8B,CAA1B,EAbR;;AAmBE,aAAO;IApB4B,CAAZ;EAAH;;EAwBnB,CAAA,KAAA,CAAA,CAAA,GAAA,EAAA;;WAED,CAAA,MAAM,mBAAA,CAAA,CAAN;EAFC,CAAA;AAhDH",
  "sourcesContent": [
    "\n\ndebug     = console.log\nrpr       = ( require 'util' ).inspect\n{ once }  = require 'events'\n\n\n# process.stdin.setEncoding null\n# for await (const line of rl) {\n\n#-----------------------------------------------------------------------------------------------------------\nuse_readline = ->\n  readline  = require 'readline'\n  rl = readline.createInterface {\n    input:        process.stdin\n    output:       process.stdout\n    historySize:  0\n    crlfDelay:    Infinity\n    terminal:     false }\n  rl.on 'line', ( line ) =>\n    # debug rpr line\n    line = line.replace /([\\ue000-\\uefff])/g, '$1 '\n    process.stdout.write line + '\\n'\n  await once rl, 'close'\n\n#-----------------------------------------------------------------------------------------------------------\nuse_itxt_splitlines = -> new Promise ( resolve, reject ) =>\n  SL              = require 'intertext-splitlines'\n  { stdin\n    stdout }      = process\n  settings        = { decode: false, keep_newlines: false, }\n  as_hex_literal  = ( buffer ) -> '\\\\x' + ( buffer.toString 'hex' )\n  ctx             = SL.new_context settings\n  lnr             = 0\n  #.........................................................................................................\n  stdin.on 'data', ( d ) ->\n    for line from SL.walk_lines ctx, d\n      lnr++\n      stdout.write ( \"\\\"dsk\\\",#{lnr},\" ) + ( as_hex_literal line ) + '\\n'\n  #.........................................................................................................\n  await process.stdin.once 'end', ->\n    for line from SL.flush ctx\n      lnr++\n      stdout.write ( \"\\\"dsk\\\",#{lnr},\" ) + ( as_hex_literal line ) + '\\n'\n      resolve()\n  #.........................................................................................................\n  return null\n\n\n############################################################################################################\ndo =>\n  # use_readline()\n  await use_itxt_splitlines()\n\n\n\n"
  ]
}